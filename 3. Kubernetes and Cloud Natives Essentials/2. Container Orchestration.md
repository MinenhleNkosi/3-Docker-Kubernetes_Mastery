# 1. Use of Containers in Cloud Native 📦
The journey of application development has always been closely tied to how we **package** and **deploy** software — and `containers` are the latest leap in that evolution 🚀.

## 🐍 Example: A Simple C# Web App
Let’s say I’ve built a small web app in C#. To run it, I’d typically need:

    🖥️ A base operating system.

    🐍 C# and .NET Core packages installed.

    📦 Additional libraries (e.g., Dapper, EF Core).

    🌐 Networking set up.

    🗄️ Connections to databases, caches, or storage systems.

Traditionally, **system administrators** would set up the environment to meet all these requirements — which can be:

* ❗ Error-prone
  
* 🔁 Time-consuming
  
* 📉 Hard to maintain

So, servers were usually set up for one specific purpose, like running just a `database` or `app server`, and then connected over the network.

<a><br /><img src="https://app.eraser.io/workspace/PdEX5bJXiE6yVrjaLFCq/preview?elements=3nwMqRlHVc-8K5zWdJn5mQ&type=embed" /></a>

<br />

## 🧮 Enter: Virtual Machines (VMs)
To make better use of hardware, **Virtual Machines** came into play:

* Emulate a full computer (`OS`, `CPU`, `RAM`, etc.)
  
* Allow multiple isolated environments on the same server.
  
* Great for running different apps side-by-side.

**But VMs have a downside**:
* ⚠️ They’re heavyweight — each one needs its own full OS kernel, which adds overhead.
  
* 🐳 The Container Revolution

**`Containers` solve both major problems**:
* ✅ Package the app + all dependencies into one portable unit.
  
* ⚡ Run more efficiently than VMs — no need for a full **OS** per app.

**`Containers` share the host `OS kernel` but remain isolated, making them**:
* 🪶 Lightweight.
  
* 🔄 Easy to replicate.
  
* 🚚 Portable across environments (dev, staging, prod).

## 🧰 Why Containers Matter
**Containers make it easier for developers to**:
* Define their app’s **environment** in a `single container image`.
  
* Ensure **consistency** across machines.
  
* Focus on writing code, not configuring servers.

**And for operations teams, containers mean**:
* More **efficient** resource usage 💰
  
* Easier **updates** and **rollbacks** 🔄
  
* Simpler scaling ⚖️

By using **containers**, I can **build**, **ship**, and **run** my applications anywhere, with confidence and consistency 🌍.

The diagram below illustarte the **difference** between **Docker images** and **VMs**: 

<a><br /><img src="https://app.eraser.io/workspace/PdEX5bJXiE6yVrjaLFCq/preview?elements=Fs2hLwEtPIwPM7rSRgDnlw&type=embed" /></a>

<br />

# 2. Running Containers with Docker & Beyond 🐳
**What Does It Mean to Run a Container?**

You might think you need Docker to run containers... but surprise! 😲
There’s actually a standard for this:

    OCI (Open Container Initiative) sets the rules with:

        📦 image-spec – how images are built

        ⚙️ runtime-spec – how containers run

Think of:

    A container image as a class 🧱
    A running container as an object (instance) 🏃

🧰 **The Tools Behind the Scenes**

    🔧 runC – The engine under the hood. It’s a low-level runtime used by Docker, Podman, and others.


    🐳 Docker uses runC behind the scenes. You can run containers like this:

docker run nginx

# 3. Building Container Images with Docker 📦
So, **why is it called a container**? 🤔
It's based on the idea of **shipping containers** — **standardized**, **stackable**, and **portable**. 🚢
Just like those metal boxes can carry goods **anywhere**, `container images` carry your **app** across systems!

## What Makes Containers Portable? 🧱
Docker brought together tools like:

* 🧩 **Namespaces** (isolation)

* 🔒 **cgroups** (resource limits)

But the game-changer was 📦 `container images`.

* A container image is like a **complete app-in-a-box**:

        Code 🧑‍💻

        Runtime 🛠️

        System tools ⚙️

        Libraries 📚

        Settings 🔧


## The OCI Standard 🌐
In 2015, Docker’s image format was donated to the **Open Container Initiative (OCI)**.

Today, it's called the **OCI image-spec** and lives on GitHub. 🐙

An image = 🗂 Filesystem bundle + 📝 Metadata

## Building an Image with a Dockerfile 🏗️
You create container images with a special file called a **Dockerfile**.
It's like a recipe 📃 for setting up your app’s environment.

Let’s containerize a simple **C# console app!** 💻

🧪 Sample Dockerfile for a C# App:

```Dockerfile
# Use the official .NET SDK image to build the app
FROM mcr.microsoft.com/dotnet/sdk:6.0 AS build

# Set the working directory inside the container
WORKDIR /app

# Copy the C# project files
COPY . .

# Restore and build the app
RUN dotnet restore
RUN dotnet publish -c Release -o out

# Use the runtime image for smaller final size
FROM mcr.microsoft.com/dotnet/runtime:6.0

# Set the working directory again
WORKDIR /app

# Copy the published output from the build stage
COPY --from=build /app/out .

# Define the entrypoint (this runs when container starts)
CMD ["dotnet", "MyApp.dll"]
```

## Building & Running the Image 🛠️
If Docker is installed, you can build your image like this:

```bash
docker build -t my-csharp-image -f Dockerfile .
```

* `-t` gives your image a name.

* `-f` tells Docker where to find your Dockerfile.

* `.` is the build context (your current folder).

## Sharing Your Image
Once built, you can **push it to a registry** (like GitHub Container Registry, Docker Hub, or a private one):

```bash
docker push my-registry.com/my-csharp-image
docker pull my-registry.com/my-csharp-image
```

# 4. Securing Your Containers 🔐 
Security is not optional when working with containers. Let’s explore how containers differ from virtual machines and what you need to protect. 🛡️

## Containers vs. Virtual Machines
Containers are **not VMs** ⚠️

They share the **same kernel** 🧠 with the host, which means:

    If one container breaks the rules, it can mess with the whole system! 💥

For example, if a container:

    Kills processes 🪓

    Adds routing rules 🛣️

    Modifies the host network 🌐
    …it can become a serious threat.

📝 Learn more about this in the [Docker capabilities docs](https://docs.docker.com/engine/reference/run/#runtime-privilege-and-linux-capabilities)

## Beware of Running as Root 🧑‍💻
One of the biggest mistakes in container security:

    ❌ Running apps as root (admin) inside containers

This gives the app way too much power.
Unfortunately, many public images still run as root by default. 😓

✅ Best practice:
Use a non-root user in your Dockerfile like this:

```dockerfile
# Create a new user
RUN useradd -m appuser
USER appuser
```

## Danger of Public Images 🌐
Pulling images from public registries like:

    🐳 Docker Hub

    🧺 Quay

...can expose your system to **malware** if you're not careful.

🕵️ Always:

    Check image source 👀

    Use official or verified images ✅

    Pin image versions 🔒 (node:18.14.2, not just node:latest)

📚 Recommended read: [Sysdig's guide to secure image building](https://sysdig.com/blog/)

## The 4 C's of Cloud Native Security 🛡️
To build a strong security model, think in layers:

1. **Cloud** ☁️ – Your cloud provider & infrastructure

2. **Cluster** 🧱 – Kubernetes, nodes, control plane

3. **Container** 📦 – Images, runtime, file permissions

4. **Code** 💻 – Application logic, dependencies

    🔐 Each layer protects the one inside it.
    So... don’t skip a layer!

Learn more in the [Kubernetes Security Docs](https://kubernetes.io/docs/concepts/security/overview/)

## 🌀 Security is a Journey

There’s no single fix for container security.
It’s an ongoing process of best practices, audits, and continuous learning.

# 5. Container Orchestration Fundamentals 🤖
Running a few containers locally? Easy.
Running **hundreds of them** across servers? Not so easy. 😅
That’s where **container orchestration** comes in! 🛠️📦

## 🧩 The Rise of Microservices
Modern apps are no longer **monoliths** 🏰 — they are built from small, self-contained services called **microservices** 🧱.

Each microservice is:

    🚢 Containerized

    🧍 Independent

    🔄 Loosely coupled

Put them together, and you’ve got a **microservice architecture** — a modular way to build modern apps.

## ⚙️ Why Orchestration?
As you scale, you face new challenges:

✅ What needs to be managed:

* 🖥️ **Compute**: Where do containers run?

* 🧮 **Scheduling**: How are containers spread across servers?

* 🔋 **Resource allocation**: CPU & memory per container?

* 💀 **Resilience**: What if a container fails?

* 📈 **Scaling**: What if traffic spikes?

* 🌐 **Networking**: How do containers talk to each other?

* 💾 **Storage**: What if data must persist?

It’s just too much to do manually... 😰

## What is Container Orchestration? 🛠️

    A container orchestration system is your robot manager 🤖
    It automates everything about running containers at scale.

These systems create a `cluster` — a **group of servers** that:

* 📡 Use a **control plane** (orchestrates everything)

* 🛠️ Use **worker nodes** (run the actual containers)

Together, they help manage container lifecycles across large systems.

## The Industry Standard – Kubernetes 🌟
There have been other systems in the past (like **Docker Swarm**, **Mesos**, **Nomad**)...
But today, one tool rules them all:

* 🧠 **Kubernetes** = Industry-standard container orchestrator

Built by Google, adopted by the CNCF, and supported everywhere 🌍.

Kubernetes lets you:

* 🔁 Automatically **restart** failed containers.

* ⬆️ Scale **up/down** based on demand.

* ⚖️ **Distribute workloads** efficiently.

* 🔐 **Secure**, **monitor**, and **connect containers** seamlessly.

## FYI
* **Microservices** = lots of small containers 🧱

* **Orchestration** = automated management 🛠️

* **Kubernetes** = the go-to solution 🧠

<a><br /><img src="https://app.eraser.io/workspace/PdEX5bJXiE6yVrjaLFCq/preview?elements=3nwMqRlHVc-8K5zWdJn5mQ&type=embed" /></a>

<br />
