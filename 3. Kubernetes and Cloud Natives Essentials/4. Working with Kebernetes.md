# 0. Kubernetes Objects ğŸ“¦
**ğŸ§± What Are Kubernetes Objects?**

Kubernetes uses **objects** (a.k.a. `resources`) to **describe how your app should run**.
These are written in YAML and submitted to the **API server**.

### ğŸ”§ They handle things like:

* Scheduling ğŸ—“ï¸

* Scaling ğŸ“ˆ

* Configuration âš™ï¸

* Networking ğŸŒ

* Security ğŸ”

## ğŸ¯ Two Types of Objects

1. **Workload Objects** â€“ Manage app containers
    (e.g. `Pod`, `Deployment`, `Job`, `DaemonSet`)

2. **Infrastructure Objects** â€“ Manage config and environment
    (e.g. `Service`, `ConfigMap`, `Secret`, `Ingress`)

Some objects are:

* **Namespaced**: exist inside a namespace (like `Deployment`)

* **Cluster-wide**: exist outside namespaces (like `Node`, `PersistentVolume`)

## âœï¸ Describing an Object in YAML
Hereâ€™s a basic Deployment YAML:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
spec: 
  replicas: 2
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.19
        ports:
        - containerPort: 80
```

## ğŸ“Œ Required Fields
| Field        | Description                                        |
| ------------ | -------------------------------------------------- |
| `apiVersion` | Which version of the object schema to use          |
| `kind`       | What type of object (e.g. Deployment, Service)     |
| `metadata`   | Name + optional labels, annotations, namespace     |
| `spec`       | What you **want** Kubernetes to do (desired state) |

## ğŸ—‚ï¸ How It Works

* You define the object (like a `Deployment`).

* You **apply it with** `kubectl apply -f file.yaml`.

* Kubernetes **stores your desired state**.

* Controllers work to **make the real state match the desired state**.

Youâ€™re not starting containers yourself â€” youâ€™re **declaring intent**, and Kubernetes makes it happen âœ….

## ğŸ“Œ FYI:

* Kubernetes uses **YAML-based objects** to manage workloads.

* Objects can be for workloads ğŸ§± or for infrastructure âš™ï¸.

* You define the state, Kubernetes maintains it.

* Objects are sent to the **API server**, validated, and stored.

# 1. Interacting with Kubernetes ğŸ§‘â€ğŸ’»

**ğŸš€ Meet** `kubectl`

The main way to talk to your Kubernetes cluster is through the **command-line tool** called `kubectl`.

You can use it to:

* View resources ğŸ“‹

* Create and delete objects â•âŒ

* Get docs on objects ğŸ“–

* Apply configs âš™ï¸

ğŸ‘‰ Install instructions: [Official Docs](https://kubernetes.io/docs/tasks/tools/#kubectl)

## ğŸ” Exploring Resources
To see what kinds of objects your cluster supports:

```bash
kubectl api-resources
```

Example output:
| NAME                   | SHORTNAMES | NAMESPACED | KIND                  |
| ---------------------- | ---------- | ---------- | --------------------- |
| configmaps             | cm         | true       | ConfigMap             |
| persistentvolumeclaims | pvc        | true       | PersistentVolumeClaim |
| namespaces             | ns         | false      | Namespace             |
| pods                   | po         | true       | Pod                   |
| services               | svc        | true       | Service               |

ğŸ’¡ Tip: Use short names like **po**, **svc**, or **pvc** to type faster!

## ğŸ“– Learn About Objects with explain
Want to know what a resource is for? Use `kubectl explain`:

```bash
kubectl explain pod
```

Drill into a specific section:

```bash
kubectl explain pod.spec
```

Output will tell you:

* What each field means

* Which fields are required

* Links to further docs

## ğŸ§ª Common kubectl Commands

You can always run:

```bash
kubectl --help
```

## ğŸ”° Basic Commands (Beginner):

* `create` â€“ Create resources from YAML or stdin

* `run` â€“ Run an image as a Pod

* `expose` â€“ Create a Service from a Pod/Deployment

* `set` â€“ Update config on existing objects

## ğŸ”§ Intermediate:

* `get` â€“ View resources

* `edit` â€“ Edit them in-place

* `delete` â€“ Remove resources

* `explain` â€“ Show docs for objects

**âœï¸ Create from file**:

```bash
kubectl create -f your-app.yaml
```

**ğŸ“¥ Apply changes (recommended):**

```bash
kubectl apply -f your-app.yaml
```

## ğŸ–¥ï¸ Graphical Interfaces

Prefer visuals over terminal? Try these GUI tools:

* [Kubernetes Dashboard](https://github.com/kubernetes/dashboard) ğŸ–¼ï¸

* [k9s](https://github.com/derailed/k9s) (by derailed) ğŸ“Ÿ â€“ terminal UI

* [Lens](https://k8slens.dev/) ğŸ‘ï¸ â€“ full-featured IDE

* [Octant (by VMware Tanzu)](https://github.com/vmware-tanzu/octant) ğŸ§­

## ğŸ§  FYI:

* Use `kubectl` to interact with Kubernetes

* Use `kubectl explain` to learn about objects

* Apply YAML files to create or update resources

* GUIs like **Lens** and **Dashboard** are great for exploring your cluster

# 2. Pod Concept ğŸ“¦
**ğŸ”‘ What is a Pod?**

A **Pod** is the **smallest deployable unit** in `Kubernetes`.

Think of a Pod as a wrapper around **one or more containers** that:

* ğŸšª **Share a network** (same IP address and port space).

* ğŸ—‚ï¸ **Can share storage** (via shared volumes).

* ğŸ§© Are treated as a **single unit of deployment**.

    * Kubernetes doesn't manage containers directlyâ€”it manages Pods.

## ğŸ¤ Why Multiple Containers in a Pod?

Sometimes, you want tightly coupled processes to run together, like:

* A main app + a logging agent

* A web server + a metrics collector

This is called the **Sidecar Pattern**. All containers in a Pod start **together** and run in **parallel**.

**Example: Pod with Sidecar:**

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: nginx-with-sidecar
spec:
  containers:
    - name: nginx
      image: nginx:1.19
      ports:
        - containerPort: 80
    - name: count
      image: busybox:1.34
      args: ["/bin/sh", "-c", "i=0; while true; do echo \"$i: $(date)\"; i=$((i+1)); sleep 1; done"]
```

âš ï¸ **Heads-up**: You can't scale these containers independently.

## â³ Init Containers
Sometimes you want to run a container before your main app starts (e.g. to wait for a service to become available). Thatâ€™s what `initContainers` are for.
**Example: Pod with Init Container**

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: myapp-pod
  labels:
    app: myapp
spec:
  containers:
    - name: myapp-container
      image: busybox
      command: ['sh', '-c', 'echo The app is running! && sleep 3600']
  initContainers:
    - name: init-myservice
      image: busybox
      command: ['sh', '-c', 'until nslookup myservice; do echo waiting for myservice; sleep 2; done;']

```

## âš™ï¸ Key Container Settings in a Pod
Here are some **important features** you can set for each container:

| Setting           | Description                                                |
| ----------------- | ---------------------------------------------------------- |
| `resources`       | Request and limit CPU/memory usage âš–ï¸                      |
| `livenessProbe`   | Check if the app is alive; restart if itâ€™s not ğŸ©º          |
| `securityContext` | Set permissions, user/group IDs, and Linux capabilities ğŸ” |

## ğŸ“š Learn More

Check the [official Pod documentation](https://kubernetes.io/docs/concepts/workloads/pods/) to explore more options like:

* Volumes

* Probes (`readinessProbe`)

* Restart policies

* Affinity and node selectors

# 3. Pod Lifecycle ğŸ”„
Pods in Kubernetes go through **well-defined lifecycle phases**. Understanding these phases helps you debug and manage workloads more effectively.

## ğŸš¦ Lifecycle Phases
â³ `Pending`

* The Pod has been accepted by the Kubernetes API, but **not all containers are running yet**.

* Reasons may include:

    * Waiting for a **scheduler decision**.

    * Downloading **container images**.

âœ… `Running`

* The Pod has been scheduled on a node.

* All containers have been **created**, and at least one is **running** or **starting**.

ğŸ `Succeeded`

* All containers in the Pod **terminated successfully** (`exit code 0`)

* They **will not be restarted**.

* Common for short-lived Pods like **batch jobs**.

âŒ `Failed`

* All containers have **terminated**, but **at least one failed** (`non-zero exit code` or terminated by the system).

* The Pod is considered a **failure**.

â“ `Unknown`

* The system **canâ€™t determine the Pod state**.

* Usually caused by **node communication issues** (e.g. node down, network problems).

## ğŸ“Œ Summary Table

| Phase     | Description                                                  |
| --------- | ------------------------------------------------------------ |
| Pending   | Waiting for scheduling and container setup                   |
| Running   | Containers are up or starting                                |
| Succeeded | All containers finished successfully (exit code 0)           |
| Failed    | One or more containers failed (non-zero exit or forced kill) |
| Unknown   | Kubernetes can't get Pod status due to node error            |


<a><br /><img src="https://app.eraser.io/workspace/M9lo0A8H1DRmdBWg5Xy8/preview?elements=DmzSNXD2OOlcrTPMWlumVg&type=embed" /></a>

# 4. Workload Objects âš™ï¸
Working directly with Pods isnâ€™t enough in a dynamic, self-healing orchestration system. If a Pod is lostâ€”say, due to node failureâ€”it doesnâ€™t come back unless something ensures it should.

To handle this, Kubernetes provides **controller objects** that manage Pods for you.

## ğŸ§© ReplicaSet

* Ensures a **specified number of Pod replicas** are running at all times.

* If a Pod fails, the ReplicaSet creates a new one.

* Commonly used **indirectly** via Deployments.

## ğŸš€ Deployment

* The **most commonly used** and feature-rich controller.

* Manages multiple ReplicaSets to:

    * Handle **rolling updates**.

    * Support **rollbacks**.

    * Manage **application versioning**.

* Ideal for **stateless apps**.

## ğŸ·ï¸ StatefulSet

* Designed for **stateful applications** like databases.

* Offers:

    * **Stable network identities**.

    * **Persistent storage**.

    * **Ordered deployments & scaling**.

* Best for workloads needing **consistency across Pod restarts**.

## ğŸ” DaemonSet

* Ensures **one Pod per node** (or subset of nodes).

* Perfect for cluster-wide services such as:

    * **Monitoring agents**.

    * **Log shippers**.

    * **Network tools**.

## â±ï¸ Job

* Runs one-time tasks to completion.

* Ideal for things like:

    * **Database migrations**.

    * **Batch processing**.

    * **Ad-hoc scripts**.

## â° CronJob

* Runs Jobs on a **schedule** (like `cron`).

* Great for:

    * **Nightly backups**

    * **Log rotation**.

    * **Periodic reports**.

<a><br /><img src="https://app.eraser.io/workspace/M9lo0A8H1DRmdBWg5Xy8/preview?elements=dGSUpZpzVOGdkTa6K-xJ8A&type=embed" /></a>

# Interactive Tutorial - Deploy an App and explore it
You can learn how to deploy an application in your **Minikube cluster** in the [second part of the interactive tutorial available in the Kubernetes documentation](https://kubernetes.io/docs/tutorials/kubernetes-basics/deploy-app/deploy-intro/).

Apply what you have learned from **"Interacting with Kubernetes"** to explore your app in the [third part of the interactive tutorial](https://kubernetes.io/docs/tutorials/kubernetes-basics/explore/explore-intro/).

# 5. Networking Objects in Kubernetes ğŸŒ
To avoid manual networking configuration for every Pod, Kubernetes uses **Services** and **Ingress** to abstract and manage connectivity efficiently.

## ğŸ”Œ Service Types:
1. **ClusterIP (default)**

* Provides a **virtual IP** within the cluster.

* Load balances traffic **internally** across Pods.

* Ideal for **internal communication** between services.

2. **NodePort**

* Opens a specific port (30000â€“32767) on **every node**.

* Maps this port to the **ClusterIP**.

* Enables **external access** to services via NodeIP:NodePort.

3. **LoadBalancer**

* Builds on NodePort by provisioning an **external load balancer**.

* Only available in cloud environments like **AWS**, **GCP**, **Azure**.

* Used for **public-facing applications**.

4. **ExternalName**

* Creates a **DNS alias** for an external service.

* No actual traffic routing by Kubernetes.

* Example:
`my-db -> my-db.aws-region-123.cloudprovider.com`

* Useful for **external service access via DNS**.

## ğŸ§  Headless Services
* Created by setting `.spec.clusterIP: None`.

* No cluster IP, **no load balancing**, no kube-proxy.

* Allows **direct DNS resolution** to individual Pod IPs.

* Common use case: **StatefulSets**, for stable identity.

## ğŸšª Ingress
Provides **external HTTP(S)** access to services via routing rules.

### âœ¨ Standard Features:

* Load balancing

* TLS termination

* Virtual hosting by hostname or path

### ğŸš€ Extended Features (varies by controller):

* URL redirects

* Custom error pages

* OAuth/OIDC-based authentication

* Rate limiting & session affinity

* Logging & observability

To use Ingress, an **Ingress Controller** must be installed (e.g., `NGINX Ingress Controller`, `Traefik`, `HAProxy`).

## ğŸ”’ NetworkPolicy
Acts as a **cluster firewall**, allowing you to:

* Restrict traffic between Pods and/or Namespaces

* Control **Ingress (incoming)** and **Egress (outgoing)** flows

* Based on **Pod selectors, namespaces, ports, and IP blocks**

Perfect for enforcing **zero-trust networking** or securing sensitive workloads.

<a><br /><img src="https://app.eraser.io/workspace/M9lo0A8H1DRmdBWg5Xy8/preview?elements=yu0MQgWdckFt8810D_lIZw&type=embed" /></a>
